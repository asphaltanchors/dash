import { pgSchema, varchar, text, date, boolean, numeric, timestamp, bigint, integer, doublePrecision } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const analyticsMart = pgSchema("analytics_mart");


export const fctOrdersInAnalyticsMart = analyticsMart.table("fct_orders", {
	orderNumber: varchar("order_number"),
	sourceType: text("source_type"),
	orderDate: date("order_date"),
	customer: text(),
	paymentMethod: text("payment_method"),
	status: text(),
	dueDate: date("due_date"),
	isTaxExempt: boolean("is_tax_exempt"),
	isPaid: boolean("is_paid"),
	isBackdated: boolean("is_backdated"),
	billingAddress: text("billing_address"),
	billingAddressCity: text("billing_address_city"),
	billingAddressState: text("billing_address_state"),
	billingAddressPostalCode: text("billing_address_postal_code"),
	billingAddressCountry: text("billing_address_country"),
	shippingAddress: text("shipping_address"),
	shippingAddressCity: text("shipping_address_city"),
	shippingAddressState: text("shipping_address_state"),
	shippingAddressPostalCode: text("shipping_address_postal_code"),
	shippingAddressCountry: text("shipping_address_country"),
	primaryCountry: text("primary_country"),
	countryCategory: text("country_category"),
	region: text(),
	shippingMethod: text("shipping_method"),
	shipDate: date("ship_date"),
	memo: text(),
	messageToCustomer: text("message_to_customer"),
	class: text(),
	currency: text(),
	exchangeRate: numeric("exchange_rate"),
	terms: text(),
	salesRep: text("sales_rep"),
	transactionId: text("transaction_id"),
	quickbooksInternalId: text("quickbooks_internal_id"),
	externalId: text("external_id"),
	createdDate: timestamp("created_date", { mode: 'string' }),
	modifiedDate: timestamp("modified_date", { mode: 'string' }),
	totalLineItemsAmount: numeric("total_line_items_amount"),
	totalTax: numeric("total_tax"),
	totalAmount: numeric("total_amount"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	itemCount: bigint("item_count", { mode: "number" }),
	effectiveTaxRate: numeric("effective_tax_rate"),
});

export const fctCompanyProductsInAnalyticsMart = analyticsMart.table("fct_company_products", {
	companyDomainKey: varchar("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: varchar("domain_type"),
	businessSizeCategory: text("business_size_category"),
	productService: varchar("product_service"),
	productServiceDescription: varchar("product_service_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: text("item_type"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTransactions: bigint("total_transactions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	purchaseDays: bigint("purchase_days", { mode: "number" }),
	totalQuantityPurchased: numeric("total_quantity_purchased"),
	totalAmountSpent: numeric("total_amount_spent"),
	avgUnitPrice: numeric("avg_unit_price"),
	minUnitPrice: numeric("min_unit_price"),
	maxUnitPrice: numeric("max_unit_price"),
	standardSalesPrice: numeric("standard_sales_price"),
	standardPurchaseCost: numeric("standard_purchase_cost"),
	priceVariancePercentage: numeric("price_variance_percentage"),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	firstPurchaseDate: date("first_purchase_date"),
	latestPurchaseDate: date("latest_purchase_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	recentTransactions: bigint("recent_transactions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lastYearTransactions: bigint("last_year_transactions", { mode: "number" }),
	daysSinceLastPurchase: integer("days_since_last_purchase"),
	transactionsPerPurchaseDay: numeric("transactions_per_purchase_day"),
	buyerStatus: text("buyer_status"),
	purchaseVolumeCategory: text("purchase_volume_category"),
	purchaseFrequencyCategory: text("purchase_frequency_category"),
	companyTotalRevenue: numeric("company_total_revenue"),
	productRevenuePercentage: numeric("product_revenue_percentage"),
	primarySalesRep: varchar("primary_sales_rep"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const bridgeCustomerCompanyInAnalyticsMart = analyticsMart.table("bridge_customer_company", {
	customerId: varchar("customer_id"),
	companyDomainKey: varchar("company_domain_key"),
	customerName: varchar("customer_name"),
	customerCompanyName: varchar("customer_company_name"),
	standardizedCustomerName: varchar("standardized_customer_name", { length: 500 }),
	customerNameNormalizationType: varchar("customer_name_normalization_type", { length: 50 }),
	mainEmail: varchar("main_email"),
	ccEmail: varchar("cc_email"),
	mainPhone: varchar("main_phone"),
	billingAddressLine1: varchar("billing_address_line_1"),
	billingAddressCity: varchar("billing_address_city"),
	billingAddressState: varchar("billing_address_state"),
	billingAddressPostalCode: varchar("billing_address_postal_code"),
	salesRep: varchar("sales_rep"),
	terms: varchar(),
	priceLevel: varchar("price_level"),
	currentBalance: numeric("current_balance"),
	customerStatus: varchar("customer_status"),
	customerCreatedDate: timestamp("customer_created_date", { mode: 'string' }),
	customerModifiedDate: timestamp("customer_modified_date", { mode: 'string' }),
	domainType: varchar("domain_type"),
	customerTotalRevenue: numeric("customer_total_revenue"),
	customerTotalOrders: numeric("customer_total_orders"),
	customerTotalLineItems: numeric("customer_total_line_items"),
	customerFirstOrderDate: date("customer_first_order_date"),
	customerLatestOrderDate: date("customer_latest_order_date"),
	customerOrderDays: numeric("customer_order_days"),
	customerValueTier: text("customer_value_tier"),
	customerActivityStatus: text("customer_activity_status"),
	ordersPerDay: numeric("orders_per_day"),
	isIndividualCustomer: boolean("is_individual_customer"),
	isMissingEmail: boolean("is_missing_email"),
	hasRevenue: boolean("has_revenue"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctCompanyOrdersTimeSeriesInAnalyticsMart = analyticsMart.table("fct_company_orders_time_series", {
	companyDomainKey: varchar("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: varchar("domain_type"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	orderYear: numeric("order_year"),
	orderQuarter: numeric("order_quarter"),
	periodKey: text("period_key"),
	periodStartDate: date("period_start_date"),
	periodEndDate: date("period_end_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	orderCount: bigint("order_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueCustomers: bigint("unique_customers", { mode: "number" }),
	totalRevenue: numeric("total_revenue"),
	avgOrderValue: numeric("avg_order_value"),
	totalUniqueProducts: numeric("total_unique_products"),
	avgProductsPerOrder: numeric("avg_products_per_order"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	largeOrders: bigint("large_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	mediumOrders: bigint("medium_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	smallOrders: bigint("small_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	microOrders: bigint("micro_orders", { mode: "number" }),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	qoqOrderGrowthPct: numeric("qoq_order_growth_pct"),
	qoqRevenueGrowthPct: numeric("qoq_revenue_growth_pct"),
	yoyOrderGrowthPct: numeric("yoy_order_growth_pct"),
	yoyRevenueGrowthPct: numeric("yoy_revenue_growth_pct"),
	yoyGrowthTrend: text("yoy_growth_trend"),
	yoyRevenueTrend: text("yoy_revenue_trend"),
	quarterlyRevenueTier: text("quarterly_revenue_tier"),
	quarterlyActivityLevel: text("quarterly_activity_level"),
	quarterLabel: text("quarter_label"),
	isCurrentQuarter: boolean("is_current_quarter"),
	exceptionalGrowthFlag: boolean("exceptional_growth_flag"),
	concerningDeclineFlag: boolean("concerning_decline_flag"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctInventoryHistoryInAnalyticsMart = analyticsMart.table("fct_inventory_history", {
	itemName: varchar("item_name"),
	inventoryDate: date("inventory_date"),
	quantityOnHand: numeric("quantity_on_hand"),
	quantityOnOrder: numeric("quantity_on_order"),
	quantityOnSalesOrder: numeric("quantity_on_sales_order"),
	availableQuantity: numeric("available_quantity"),
	totalInventoryVisibility: numeric("total_inventory_visibility"),
	previousQuantityOnHand: numeric("previous_quantity_on_hand"),
	quantityChange: numeric("quantity_change"),
	productDescription: varchar("product_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	unitOfMeasure: varchar("unit_of_measure"),
	salesPrice: numeric("sales_price"),
	purchaseCost: numeric("purchase_cost"),
	inventoryValueAtCost: numeric("inventory_value_at_cost"),
	inventoryValueAtSalesPrice: numeric("inventory_value_at_sales_price"),
	itemStatus: varchar("item_status"),
	isBackup: boolean("is_backup"),
	originalSnapshotDate: varchar("original_snapshot_date"),
});

export const fctCompaniesInAnalyticsMart = analyticsMart.table("fct_companies", {
	companyDomainKey: varchar("company_domain_key"),
	domainType: varchar("domain_type"),
	companyName: varchar("company_name"),
	primaryEmail: varchar("primary_email"),
	primaryPhone: varchar("primary_phone"),
	primaryBillingAddressLine1: varchar("primary_billing_address_line_1"),
	primaryBillingCity: varchar("primary_billing_city"),
	primaryBillingState: varchar("primary_billing_state"),
	primaryBillingPostalCode: varchar("primary_billing_postal_code"),
	primaryCountry: text("primary_country"),
	region: text(),
	countryCategory: text("country_category"),
	customerCount: integer("customer_count"),
	uniqueCustomerNames: integer("unique_customer_names"),
	uniqueCompanyNames: integer("unique_company_names"),
	totalCurrentBalance: numeric("total_current_balance"),
	totalRevenue: numeric("total_revenue"),
	totalOrders: integer("total_orders"),
	totalLineItems: integer("total_line_items"),
	firstOrderDate: date("first_order_date"),
	latestOrderDate: date("latest_order_date"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	customerNamesSample: text("customer_names_sample"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const dimCompanyHealthInAnalyticsMart = analyticsMart.table("dim_company_health", {
	companyDomainKey: varchar("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: varchar("domain_type"),
	businessSizeCategory: text("business_size_category"),
	revenueCategory: text("revenue_category"),
	healthScore: numeric("health_score"),
	customerArchetype: text("customer_archetype"),
	activityStatus: text("activity_status"),
	engagementLevel: text("engagement_level"),
	growthTrendDirection: text("growth_trend_direction"),
	combinedGrowthTrend: text("combined_growth_trend"),
	orderFrequencyCategory: text("order_frequency_category"),
	daysSinceLastOrder: integer("days_since_last_order"),
	lastOrderDate: date("last_order_date"),
	firstOrderDate: date("first_order_date"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalOrders: bigint("total_orders", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeYears: bigint("active_years", { mode: "number" }),
	ordersPerYear: numeric("orders_per_year"),
	totalRevenue: numeric("total_revenue"),
	avgOrderValue: numeric("avg_order_value"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersLast90Days: bigint("orders_last_90_days", { mode: "number" }),
	revenueLast90Days: numeric("revenue_last_90_days"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersLastYear: bigint("orders_last_year", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	ordersPriorYear: bigint("orders_prior_year", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	productDiversityScore: bigint("product_diversity_score", { mode: "number" }),
	revenuePercentile: doublePrecision("revenue_percentile"),
	healthCategory: text("health_category"),
	atRiskFlag: boolean("at_risk_flag"),
	growthOpportunityFlag: boolean("growth_opportunity_flag"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});

export const fctOrderLineItemsInAnalyticsMart = analyticsMart.table("fct_order_line_items", {
	lineItemId: varchar("line_item_id"),
	orderNumber: varchar("order_number"),
	sourceType: text("source_type"),
	orderDate: date("order_date"),
	customer: varchar(),
	paymentMethod: varchar("payment_method"),
	status: text(),
	dueDate: date("due_date"),
	productService: varchar("product_service"),
	productServiceDescription: varchar("product_service_description"),
	productServiceQuantity: numeric("product_service_quantity"),
	productServiceRate: numeric("product_service_rate"),
	productServiceAmount: numeric("product_service_amount"),
	productServiceClass: varchar("product_service_class"),
	unitOfMeasure: varchar("unit_of_measure"),
	customerSalesTaxCode: varchar("customer_sales_tax_code"),
	isTaxExempt: boolean("is_tax_exempt"),
	productServiceSalesTaxCode: varchar("product_service_sales_tax_code"),
	billingAddress: text("billing_address"),
	billingAddressCity: varchar("billing_address_city"),
	billingAddressState: varchar("billing_address_state"),
	billingAddressPostalCode: varchar("billing_address_postal_code"),
	billingAddressCountry: text("billing_address_country"),
	shippingAddress: text("shipping_address"),
	shippingAddressCity: varchar("shipping_address_city"),
	shippingAddressState: varchar("shipping_address_state"),
	shippingAddressPostalCode: varchar("shipping_address_postal_code"),
	shippingAddressCountry: text("shipping_address_country"),
	primaryCountry: text("primary_country"),
	countryCategory: text("country_category"),
	region: text(),
	shippingMethod: varchar("shipping_method"),
	shipDate: date("ship_date"),
	memo: varchar(),
	messageToCustomer: varchar("message_to_customer"),
	terms: varchar(),
	salesRep: varchar("sales_rep"),
	class: varchar(),
	productServiceServiceDate: varchar("product_service_service_date"),
	inventorySite: varchar("inventory_site"),
	inventoryBin: varchar("inventory_bin"),
	serialNo: varchar("serial_no"),
	lotNo: varchar("lot_no"),
	externalId: varchar("external_id"),
	quickbooksInternalId: varchar("quickbooks_internal_id"),
	currency: varchar(),
	exchangeRate: numeric("exchange_rate"),
	createdDate: timestamp("created_date", { mode: 'string' }),
	modifiedDate: timestamp("modified_date", { mode: 'string' }),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	productSalesDescription: varchar("product_sales_description"),
	standardSalesPrice: numeric("standard_sales_price"),
	standardPurchaseCost: numeric("standard_purchase_cost"),
	marginPercentage: numeric("margin_percentage"),
	marginAmount: numeric("margin_amount"),
});

export const fctProductsInAnalyticsMart = analyticsMart.table("fct_products", {
	quickBooksInternalId: varchar("quick_books_internal_id"),
	itemName: varchar("item_name"),
	salesDescription: varchar("sales_description"),
	productFamily: text("product_family"),
	materialType: text("material_type"),
	isKit: boolean("is_kit"),
	itemType: varchar("item_type"),
	itemSubtype: varchar("item_subtype"),
	purchaseDescription: varchar("purchase_description"),
	salesPrice: numeric("sales_price"),
	purchaseCost: numeric("purchase_cost"),
	marginPercentage: numeric("margin_percentage"),
	marginAmount: numeric("margin_amount"),
	manufacturerSPartNumber: varchar("manufacturer_s_part_number"),
	unitOfMeasure: varchar("unit_of_measure"),
	loadDate: varchar("load_date"),
	snapshotDate: varchar("snapshot_date"),
});

export const fctCompanyOrdersInAnalyticsMart = analyticsMart.table("fct_company_orders", {
	companyDomainKey: varchar("company_domain_key"),
	companyName: varchar("company_name"),
	domainType: varchar("domain_type"),
	businessSizeCategory: text("business_size_category"),
	orderNumber: varchar("order_number"),
	orderType: text("order_type"),
	orderDate: date("order_date"),
	customerName: varchar("customer_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	lineItemCount: bigint("line_item_count", { mode: "number" }),
	calculatedOrderTotal: numeric("calculated_order_total"),
	reportedOrderTotal: numeric("reported_order_total"),
	orderTax: numeric("order_tax"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueProducts: bigint("unique_products", { mode: "number" }),
	productFamilies: text("product_families"),
	materialTypes: text("material_types"),
	kitQuantity: numeric("kit_quantity"),
	kitAmount: numeric("kit_amount"),
	avgMarginPercentage: numeric("avg_margin_percentage"),
	salesRep: varchar("sales_rep"),
	paymentMethod: varchar("payment_method"),
	terms: varchar(),
	orderYear: numeric("order_year"),
	orderQuarter: numeric("order_quarter"),
	recencyCategory: text("recency_category"),
	orderSizeCategory: text("order_size_category"),
	productDiversity: text("product_diversity"),
	daysSinceOrder: integer("days_since_order"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
});
export const baseFctOrdersCurrentInAnalyticsMart = analyticsMart.view("base_fct_orders_current", {	orderNumber: varchar("order_number"),
	sourceType: text("source_type"),
	orderDate: date("order_date"),
	customer: text(),
	paymentMethod: text("payment_method"),
	status: text(),
	dueDate: date("due_date"),
	isTaxExempt: boolean("is_tax_exempt"),
	isPaid: boolean("is_paid"),
	isBackdated: boolean("is_backdated"),
	billingAddress: text("billing_address"),
	billingAddressCity: text("billing_address_city"),
	billingAddressState: text("billing_address_state"),
	billingAddressPostalCode: text("billing_address_postal_code"),
	billingAddressCountry: text("billing_address_country"),
	shippingAddress: text("shipping_address"),
	shippingAddressCity: text("shipping_address_city"),
	shippingAddressState: text("shipping_address_state"),
	shippingAddressPostalCode: text("shipping_address_postal_code"),
	shippingAddressCountry: text("shipping_address_country"),
	primaryCountry: text("primary_country"),
	countryCategory: text("country_category"),
	region: text(),
	shippingMethod: text("shipping_method"),
	shipDate: date("ship_date"),
	memo: text(),
	messageToCustomer: text("message_to_customer"),
	class: text(),
	currency: text(),
	exchangeRate: numeric("exchange_rate"),
	terms: text(),
	salesRep: text("sales_rep"),
	transactionId: text("transaction_id"),
	quickbooksInternalId: text("quickbooks_internal_id"),
	externalId: text("external_id"),
	createdDate: timestamp("created_date", { mode: 'string' }),
	modifiedDate: timestamp("modified_date", { mode: 'string' }),
	totalLineItemsAmount: numeric("total_line_items_amount"),
	totalTax: numeric("total_tax"),
	totalAmount: numeric("total_amount"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	itemCount: bigint("item_count", { mode: "number" }),
	effectiveTaxRate: numeric("effective_tax_rate"),
}).as(sql`SELECT fct_orders.order_number, fct_orders.source_type, fct_orders.order_date, fct_orders.customer, fct_orders.payment_method, fct_orders.status, fct_orders.due_date, fct_orders.is_tax_exempt, fct_orders.is_paid, fct_orders.is_backdated, fct_orders.billing_address, fct_orders.billing_address_city, fct_orders.billing_address_state, fct_orders.billing_address_postal_code, fct_orders.billing_address_country, fct_orders.shipping_address, fct_orders.shipping_address_city, fct_orders.shipping_address_state, fct_orders.shipping_address_postal_code, fct_orders.shipping_address_country, fct_orders.primary_country, fct_orders.country_category, fct_orders.region, fct_orders.shipping_method, fct_orders.ship_date, fct_orders.memo, fct_orders.message_to_customer, fct_orders.class, fct_orders.currency, fct_orders.exchange_rate, fct_orders.terms, fct_orders.sales_rep, fct_orders.transaction_id, fct_orders.quickbooks_internal_id, fct_orders.external_id, fct_orders.created_date, fct_orders.modified_date, fct_orders.total_line_items_amount, fct_orders.total_tax, fct_orders.total_amount, fct_orders.item_count, fct_orders.effective_tax_rate FROM analytics_mart.fct_orders WHERE fct_orders.order_date <= CURRENT_DATE`);